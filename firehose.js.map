{
  "version": 3,
  "sources": ["src/index.js", "src/decode/car/utilities/byte-reader.js", "src/decode/multibase/utils.js", "src/decode/multibase/base32.js", "src/decode/cbor/varint.js", "src/decode/cbor/cid.js", "src/decode/multibase/base64.js", "src/decode/cbor/bytes.js", "src/decode/cbor/cid-link.js", "src/decode/cbor/decode.js", "src/decode/car/utilities/sync-car-reader.js", "src/decode/car/reader.js", "src/read-car.js", "package.json", "src/firehose.js"],
  "sourcesContent": ["export * from './read-car';\nexport * from './firehose';", "// @ts-check\n\n/**\n * @typedef {{\n *  readonly pos: number;\n *  upto(size: number): Uint8Array;\n *  exactly(size: number, seek: boolean): Uint8Array;\n *  seek(size: number): void;\n * }} SyncByteReader\n */\n\n/**\n * @param {Uint8Array} buf\n * @returns {SyncByteReader}\n */\nexport const createUint8Reader = (buf) => {\n  let pos = 0;\n\n  return {\n    get pos() {\n      return pos;\n    },\n\n    seek(size) {\n      pos += size;\n    },\n    upto(size) {\n      return buf.subarray(pos, pos + Math.min(size, buf.length - pos));\n    },\n    exactly(size, seek) {\n      if (size > buf.length - pos) {\n        throw new RangeError('unexpected end of data');\n      }\n\n      const slice = buf.subarray(pos, pos + size);\n      if (seek) {\n        pos += size;\n      }\n\n      return slice;\n    },\n  };\n};\n", "// @ts-check\n\nexport const allocUnsafe = (size) => {\n  return new Uint8Array(size);\n};\n\nexport const createRfc4648Encode = (alphabet, bitsPerChar, pad) => {\n  return (bytes) => {\n    const mask = (1 << bitsPerChar) - 1;\n    let str = '';\n    let bits = 0; // Number of bits currently in the buffer\n    let buffer = 0; // Bits waiting to be written out, MSB first\n    for (let i = 0; i < bytes.length; ++i) {\n      // Slurp data into the buffer:\n      buffer = (buffer << 8) | bytes[i];\n      bits += 8;\n      // Write out as much as we can:\n      while (bits > bitsPerChar) {\n        bits -= bitsPerChar;\n        str += alphabet[mask & (buffer >> bits)];\n      }\n    }\n    // Partial character:\n    if (bits !== 0) {\n      str += alphabet[mask & (buffer << (bitsPerChar - bits))];\n    }\n    // Add padding characters until we hit a byte boundary:\n    if (pad) {\n      while (((str.length * bitsPerChar) & 7) !== 0) {\n        str += '=';\n      }\n    }\n    return str;\n  };\n};\n\nexport const createRfc4648Decode = (alphabet, bitsPerChar, pad) => {\n  // Build the character lookup table:\n  const codes = {};\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n  return (str) => {\n    // Count the padding bytes:\n    let end = str.length;\n    while (pad && str[end - 1] === '=') {\n      --end;\n    }\n    // Allocate the output:\n    const bytes = allocUnsafe(((end * bitsPerChar) / 8) | 0);\n    // Parse the data:\n    let bits = 0; // Number of bits currently in the buffer\n    let buffer = 0; // Bits waiting to be written out, MSB first\n    let written = 0; // Next byte to write\n    for (let i = 0; i < end; ++i) {\n      // Read one character from the string:\n      const value = codes[str[i]];\n      if (value === undefined) {\n        throw new SyntaxError(`invalid base string`);\n      }\n      // Append the bits to the buffer:\n      buffer = (buffer << bitsPerChar) | value;\n      bits += bitsPerChar;\n      // Write out some bits if the buffer has a byte's worth:\n      if (bits >= 8) {\n        bits -= 8;\n        bytes[written++] = 0xff & (buffer >> bits);\n      }\n    }\n    // Verify that we have received just enough bits:\n    if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n      throw new SyntaxError('unexpected end of data');\n    }\n    return bytes;\n  };\n};", "// @ts-check\n\nimport { createRfc4648Decode, createRfc4648Encode } from './utils';\n\nconst BASE32_CHARSET = 'abcdefghijklmnopqrstuvwxyz234567';\nexport const fromBase32 = /*#__PURE__*/ createRfc4648Decode(BASE32_CHARSET, 5, false);\nexport const toBase32 = /*#__PURE__*/ createRfc4648Encode(BASE32_CHARSET, 5, false);\n", "// @ts-check\n\nconst MSB = 0x80;\nconst REST = 0x7f;\nconst MSBALL = ~REST;\nconst INT = 2 ** 31;\nconst N1 = 2 ** 7;\nconst N2 = 2 ** 14;\nconst N3 = 2 ** 21;\nconst N4 = 2 ** 28;\nconst N5 = 2 ** 35;\nconst N6 = 2 ** 42;\nconst N7 = 2 ** 49;\nconst N8 = 2 ** 56;\nconst N9 = 2 ** 63;\n/**\n * Encodes a varint\n * @param num Number to encode\n * @param buf Buffer to write on\n * @param offset Starting position on the buffer\n * @returns The amount of bytes written\n */\nexport const encode = (num, buf, offset = 0) => {\n  if (num > Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('could not encode varint');\n  }\n  const start = offset;\n  while (num >= INT) {\n    buf[offset++] = (num & 0xff) | MSB;\n    num /= 128;\n  }\n  while (num & MSBALL) {\n    buf[offset++] = (num & 0xff) | MSB;\n    num >>>= 7;\n  }\n  buf[offset] = num | 0;\n  return offset - start + 1;\n};\n/**\n * Decodes a varint\n * @param buf Buffer to read from\n * @param offset Starting position on the buffer\n * @returns A tuple containing the resulting number, and the amount of bytes read\n */\nexport const decode = (buf, offset = 0) => {\n  // deno-lint-ignore prefer-const\n  let l = buf.length;\n  let res = 0;\n  let shift = 0;\n  let counter = offset;\n  let b;\n  do {\n    if (counter >= l) {\n      throw new RangeError('could not decode varint');\n    }\n    b = buf[counter++];\n    res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB);\n  return [res, counter - offset];\n};\n/**\n * Returns encoding length\n * @param num The number to encode\n * @returns Amount of bytes needed for encoding\n */\nexport const encodingLength = (num) => {\n  return num < N1\n    ? 1\n    : num < N2\n      ? 2\n      : num < N3\n        ? 3\n        : num < N4\n          ? 4\n          : num < N5\n            ? 5\n            : num < N6\n              ? 6\n              : num < N7\n                ? 7\n                : num < N8\n                  ? 8\n                  : num < N9\n                    ? 9\n                    : 10;\n};\n", "// @ts-check\n\n/**\n * Raw digest information\n * @typedef {{\n *  code: number;\n *  size: number;\n *  digest: Uint8Array;\n *  bytes: Uint8Array;\n * }} Digest\n */\n\n/**\n * CID information\n * @typedef {{\n *  version: number;\n *  code: number;\n *  digest: Digest;\n *  bytes: Uint8Array;\n * }} CID\n */\n\n\n/**\n * @module\n * Bare minimum implementation for creating, parsing, and formatting\n * AT Protocol-blessed CIDv1 format.\n *\n * As specified by AT Protocol, the blessed format is:\n * - Multibase: `base32` (b)\n * - Multicodec: `dag-cbor` (0x71) for record, `raw` (0x55) for blobs\n * - Multihash: `sha-256` (0x12)\n */\nimport { fromBase32, toBase32 } from '../multibase/base32';\n\nimport { decode as varint_decode, encode as varint_encode, encodingLength as varint_encodingLength } from './varint';\n\n/**\n * Parse a CID string\n */\nexport const parse = (cid) => {\n  if (cid[0] !== 'b') {\n    throw new Error(`only base32 cidv1 is supported`);\n  }\n  const bytes = fromBase32(cid.slice(1));\n  return decode(bytes);\n};\n/**\n * Provides information regarding the CID buffer\n */\nexport const inspect = (initialBytes) => {\n  let offset = 0;\n  const next = () => {\n    const [i, length] = varint_decode(initialBytes.subarray(offset));\n    offset += length;\n    return i;\n  };\n  let version = next();\n  let codec = 0x70; // dag-pb\n  if (version === 18) {\n    // CIDv0\n    version = 0;\n    offset = 0;\n  }\n  else {\n    codec = next();\n  }\n  if (version !== 1) {\n    throw new RangeError(`only cidv1 is supported`);\n  }\n  const prefixSize = offset;\n  const multihashCode = next();\n  const digestSize = next();\n  const size = offset + digestSize;\n  const multihashSize = size - prefixSize;\n  return { version, codec, multihashCode, digestSize, multihashSize, size };\n};\n/**\n * Decode the first CID contained, and return the remainder.\n * @param bytes Buffer to decode\n * @returns A tuple containing the first CID in the buffer, and the remainder\n */\nexport const decodeFirst = (bytes) => {\n  const specs = inspect(bytes);\n  const prefixSize = specs.size - specs.multihashSize;\n  const multihashBytes = bytes.subarray(prefixSize, prefixSize + specs.multihashSize);\n  if (multihashBytes.byteLength !== specs.multihashSize) {\n    throw new RangeError('incorrect cid length');\n  }\n  const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n  const digest = {\n    code: specs.multihashCode,\n    size: specs.multihashSize,\n    digest: digestBytes,\n    bytes: multihashBytes,\n  };\n  const cid = {\n    version: 1,\n    code: specs.codec,\n    digest: digest,\n    bytes: bytes.subarray(0, specs.size),\n  };\n  return [cid, bytes.subarray(specs.size)];\n};\n/**\n * Decodes a CID buffer\n */\nexport const decode = (bytes) => {\n  const [cid, remainder] = decodeFirst(bytes);\n  if (remainder.length !== 0) {\n    throw new Error(`incorrect cid length`);\n  }\n  return cid;\n};\n/**\n * Creates a CID\n */\nexport const create = async (code, input) => {\n  const digest = createDigest(0x12, new Uint8Array(await crypto.subtle.digest('sha-256', input)));\n  const bytes = encode(1, code, digest.bytes);\n  return {\n    version: 1,\n    code: code,\n    digest: digest,\n    bytes: bytes,\n  };\n};\n/**\n * Serialize CID into a string\n */\nexport const format = (cid) => {\n  return 'b' + toBase32(cid.bytes);\n};\nexport const createDigest = (code, digest) => {\n  const size = digest.byteLength;\n  const sizeOffset = varint_encodingLength(code);\n  const digestOffset = sizeOffset + varint_encodingLength(size);\n  const bytes = new Uint8Array(digestOffset + size);\n  varint_encode(code, bytes, 0);\n  varint_encode(size, bytes, sizeOffset);\n  bytes.set(digest, digestOffset);\n  return {\n    code: code,\n    size: size,\n    digest: digest,\n    bytes: bytes,\n  };\n};\nexport const encode = (version, code, multihash) => {\n  const codeOffset = varint_encodingLength(version);\n  const hashOffset = codeOffset + varint_encodingLength(code);\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength);\n  varint_encode(version, bytes, 0);\n  varint_encode(code, bytes, codeOffset);\n  bytes.set(multihash, hashOffset);\n  return bytes;\n};\n", "// @ts-check\n\nimport { createRfc4648Decode, createRfc4648Encode } from './utils';\n\nconst BASE64_CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nconst HAS_UINT8_BASE64_SUPPORT = 'fromBase64' in Uint8Array;\n\nexport const _fromBase64Polyfill = /*#__PURE__*/ createRfc4648Decode(BASE64_CHARSET, 6, false);\n\nexport const _toBase64Polyfill = /*#__PURE__*/ createRfc4648Encode(BASE64_CHARSET, 6, false);\n\nconst WS_PAD_RE = /[\\s=]/;\n\nexport const _fromBase64Native = (str) => {\n  if (str.length % 4 === 1 || WS_PAD_RE.test(str)) {\n    throw new SyntaxError(`invalid base64 string`);\n  }\n  return /** @type {*} */(Uint8Array).fromBase64(str, { alphabet: 'base64', lastChunkHandling: 'loose' });\n};\n\nexport const _toBase64Native = (bytes) => {\n  return bytes.toBase64({ alphabet: 'base64', omitPadding: true });\n};\n\nexport const fromBase64 = !HAS_UINT8_BASE64_SUPPORT ? _fromBase64Polyfill : _fromBase64Native;\n\nexport const toBase64 = !HAS_UINT8_BASE64_SUPPORT ? _toBase64Polyfill : _toBase64Native;\n", "// @ts-check\n\nimport { fromBase64, toBase64 } from '../multibase/base64';\n\nexport class BytesWrapper {\n  buf;\n  constructor(buf) {\n    this.buf = buf;\n  }\n  get $bytes() {\n    return toBase64(this.buf);\n  }\n  toJSON() {\n    return { $bytes: this.$bytes };\n  }\n}\nexport const toBytes = (buf) => {\n  return new BytesWrapper(buf);\n};\nexport const fromBytes = (bytes) => {\n  if (bytes instanceof BytesWrapper) {\n    return bytes.buf;\n  }\n  return fromBase64(bytes.$bytes);\n};\n\n", "// @ts-check\n\nimport { decode, parse } from './cid';\nimport { toBase32 } from '../multibase/base32';\nclass CIDLinkWrapper {\n  $bytes;\n  constructor($bytes) {\n    this.$bytes = $bytes;\n  }\n  get $cid() {\n    return decode(this.$bytes);\n  }\n  get $link() {\n    return 'b' + toBase32(this.$bytes);\n  }\n  toJSON() {\n    return { $link: this.$link };\n  }\n}\nexport const toCIDLink = (value) => {\n  return 'b' + toBase32(value.bytes || value);\n  if (value instanceof Uint8Array) {\n    return 'b' + toBase32(value);\n    return new CIDLinkWrapper(value);\n  }\n  return 'b' + toBase32(value.bytes);\n  return new CIDLinkWrapper(value.bytes);\n};\n\nexport const fromCIDLink = (link) => {\n  if (link instanceof CIDLinkWrapper) {\n    return link.$cid;\n  }\n  return parse(link.$link);\n};\n//# sourceMappingURL=cid-link.js.map", "// @ts-check\n\nimport { toBytes } from './bytes';\nimport { toCIDLink } from './cid-link';\nconst utf8d = new TextDecoder();\nconst readArgument = (state, info) => {\n  if (info < 24) {\n    return info;\n  }\n  switch (info) {\n    case 24:\n      return readUint8(state);\n    case 25:\n      return readUint16(state);\n    case 26:\n      return readUint32(state);\n    case 27:\n      return readUint64(state);\n  }\n  throw new Error(`invalid argument encoding; got ${info}`);\n};\nconst readFloat64 = (state) => {\n  const value = state.v.getFloat64(state.p);\n  state.p += 8;\n  return value;\n};\nconst readUint8 = (state) => {\n  const value = state.v.getUint8(state.p);\n  state.p += 1;\n  return value;\n};\nconst readUint16 = (state) => {\n  const value = state.v.getUint16(state.p);\n  state.p += 2;\n  return value;\n};\nconst readUint32 = (state) => {\n  const value = state.v.getUint32(state.p);\n  state.p += 4;\n  return value;\n};\nconst readUint64 = (state) => {\n  const hi = state.v.getUint32(state.p);\n  const lo = state.v.getUint32(state.p + 4);\n  if (hi > 0x1fffff) {\n    throw new RangeError(`can't decode integers beyond safe integer range`);\n  }\n  // prettier-ignore\n  const value = (hi * (2 ** 32)) + lo;\n  state.p += 8;\n  return value;\n};\nconst readString = (state, length) => {\n  const slice = state.b.subarray(state.p, (state.p += length));\n  return utf8d.decode(slice);\n};\nconst readBytes = (state, length) => {\n  const slice = state.b.subarray(state.p, (state.p += length));\n  return toBytes(slice);\n};\nconst readCid = (state, length) => {\n  // CID bytes are prefixed with 0x00 for historical reasons, apparently.\n  const slice = state.b.subarray(state.p + 1, (state.p += length));\n  return toCIDLink(slice);\n};\nconst readValue = (state) => {\n  const prelude = readUint8(state);\n  const type = prelude >> 5;\n  const info = prelude & 0x1f;\n  if (type === 0) {\n    const value = readArgument(state, info);\n    return value;\n  }\n  if (type === 1) {\n    const value = readArgument(state, info);\n    return -1 - value;\n  }\n  if (type === 2) {\n    const len = readArgument(state, info);\n    return readBytes(state, len);\n  }\n  if (type === 3) {\n    const len = readArgument(state, info);\n    return readString(state, len);\n  }\n  if (type === 4) {\n    const len = readArgument(state, info);\n    const array = new Array(len);\n    for (let idx = 0; idx < len; idx++) {\n      array[idx] = readValue(state);\n    }\n    return array;\n  }\n  if (type === 5) {\n    const len = readArgument(state, info);\n    const object = {};\n    for (let idx = 0; idx < len; idx++) {\n      const key = readValue(state);\n      if (typeof key !== 'string') {\n        throw new TypeError(`expected map to only have string keys; got ${typeof key}`);\n      }\n      object[key] = readValue(state);\n    }\n    return object;\n  }\n  if (type === 6) {\n    const tag = readArgument(state, info);\n    if (tag === 42) {\n      const prelude = readUint8(state);\n      const type = prelude >> 5;\n      const info = prelude & 0x1f;\n      if (type !== 2) {\n        throw new TypeError(`expected cid tag to have bytes value; got ${type}`);\n      }\n      const len = readArgument(state, info);\n      return readCid(state, len);\n    }\n    throw new TypeError(`unsupported tag; got ${tag}`);\n  }\n  if (type === 7) {\n    switch (info) {\n      case 20:\n        return false;\n      case 21:\n        return true;\n      case 22:\n        return null;\n      case 27:\n        return readFloat64(state);\n    }\n    throw new Error(`invalid simple value; got ${info}`);\n  }\n  throw new TypeError(`invalid type; got ${type}`);\n};\nexport const decodeFirst = (buf) => {\n  const state = {\n    b: buf,\n    v: new DataView(buf.buffer, buf.byteOffset, buf.byteLength),\n    p: 0,\n  };\n  const value = readValue(state);\n  const remainder = buf.subarray(state.p);\n  return [value, remainder];\n};\nexport const decode = (buf) => {\n  const [value, remainder] = decodeFirst(buf);\n  if (remainder.length !== 0) {\n    throw new Error(`decoded value contains remainder`);\n  }\n  return value;\n};", "// @ts-check\n\nimport { encode as CID_encode } from '../../cbor/cid';\nimport { decode as varint_decode } from '../../cbor/varint';\nimport { decode as CBOR_decode } from '../../cbor/decode';\n\n/**\n * @typedef {{\n *  version: 1;\n *  roots: string[];\n * }} CarV1Header\n */\n\n/** @returns {value is CarV1Header} */\nconst isCarV1Header = (value) => {\n  if (value === null || typeof value !== 'object') {\n    return false;\n  }\n\n  const { version, roots } = value;\n  return version === 1 && Array.isArray(roots) && roots.every((root) => typeof root === 'string');\n};\n\n/**\n * @param {import('./byte-reader').SyncByteReader} reader\n * @param {number} size\n */\nconst readVarint = (reader, size) => {\n  const buf = reader.upto(size);\n  if (buf.length === 0) {\n    throw new RangeError(`unexpected end of data`);\n  }\n\n  const [int, read] = varint_decode(buf);\n  reader.seek(read);\n\n  return int;\n};\n\n/**\n * @param {import('./byte-reader').SyncByteReader} reader\n */\nconst readHeader = (reader) => {\n  const length = readVarint(reader, 8);\n  if (length === 0) {\n    throw new RangeError(`invalid car header; length=0`);\n  }\n\n  const rawHeader = reader.exactly(length, true);\n  const header = CBOR_decode(rawHeader);\n  if (!isCarV1Header(header)) {\n    throw new TypeError(`expected a car v1 archive`);\n  }\n\n  return header;\n};\n\n/**\n * @param {import('./byte-reader').SyncByteReader} reader\n */\nconst readMultihashDigest = (reader) => {\n  const first = reader.upto(8);\n\n  const [code, codeOffset] = varint_decode(first);\n  const [size, sizeOffset] = varint_decode(first.subarray(codeOffset));\n\n  const offset = codeOffset + sizeOffset;\n\n  const bytes = reader.exactly(offset + size, true);\n  const digest = bytes.subarray(offset);\n\n  return {\n    code: code,\n    size: size,\n    digest: digest,\n    bytes: bytes,\n  };\n};\n\n/**\n * @param {import('./byte-reader').SyncByteReader} reader\n */\nconst readCid = (reader) => {\n  const version = readVarint(reader, 8);\n  if (version !== 1) {\n    throw new Error(`expected a cidv1`);\n  }\n\n  const codec = readVarint(reader, 8);\n  const digest = readMultihashDigest(reader);\n\n  const cid = {\n    version: version,\n    code: codec,\n    digest: digest,\n    bytes: CID_encode(version, codec, digest.bytes),\n  };\n\n  return cid;\n};\n\n/**\n * @param {import('./byte-reader').SyncByteReader} reader\n */\nconst readBlockHeader = (reader) => {\n  const start = reader.pos;\n\n  let size = readVarint(reader, 8);\n  if (size === 0) {\n    throw new Error(`invalid car section; length=0`);\n  }\n\n  size += reader.pos - start;\n\n  const cid = readCid(reader);\n  const blockSize = size - Number(reader.pos - start);\n\n  return { cid, blockSize };\n};\n\n/**\n * @param {import('./byte-reader').SyncByteReader} reader\n */\nexport const createCarReader = (reader) => {\n  const { roots } = readHeader(reader);\n\n  return {\n    roots,\n    /** @returns {Generator<{ cid: import('../../cbor/cid').CID; bytes: Uint8Array }>} */\n    *iterate() {\n      while (reader.upto(8).length > 0) {\n        const { cid, blockSize } = readBlockHeader(reader);\n        const bytes = reader.exactly(blockSize, true);\n\n        yield { cid, bytes };\n      }\n    },\n  };\n};\n", "// @ts-check\n\nimport { createUint8Reader } from './utilities/byte-reader';\nimport { createCarReader } from './utilities/sync-car-reader';\n\n/** @param {Uint8Array} buffer */\nexport const readCar = (buffer) => {\n  const reader = createUint8Reader(buffer);\n  return createCarReader(reader);\n};\n", "// @ts-check\n\n// import { decode as decodeCBOR } from './decode/cbor-x/decoder';\n// import { decode as decodeCID } from './decode/js-multiformats/cid';\n// import { CarBufferReader } from './decode/js-car/buffer-reader-browser';\n\nimport { readCar } from './decode/car/reader';\nimport { decode as decodeCBOR2 } from './decode/cbor/decode';\nimport { decode as decodeCID2 } from './decode/cbor/cid';\nimport { toBase32 } from './decode/multibase/base32';\n\nconst YIELD_AFTER_ITERATION = 300;\n\n/**\n * @param {ArrayBuffer | Uint8Array} messageBuf\n * @param {string} did\n */\nexport function readCAR(messageBuf, did) {\n  if (typeof messageBuf === 'string')\n    [messageBuf, did] = /** @type {[any, any]} */([did, messageBuf]);\n\n  /** @type {import('./firehose').FirehoseRecord[] & { parseTime: number } | undefined} */\n  let last;\n  for (const _chunk of sequenceReadCAR(messageBuf, did)) {\n    if (_chunk) last = _chunk;\n  }\n  return   /** @type {NonNullable<typeof last>} */(last);\n}\n\n// /**\n//  * @param {ArrayBuffer | Uint8Array} messageBuf\n//  * @param {string} did\n//  * @returns {Generator<import('./firehose').FirehoseRecord[] & { parseTime: number } | undefined>}\n//  */\n// export function* sequenceReadCAR(messageBuf, did) {\n//   if (typeof messageBuf === 'string')\n//     [messageBuf, did] = /** @type {[any, any]} */([did, messageBuf]);\n\n//   const parseStart = Date.now();\n//   let pauseTime = 0;\n\n//   const bytes = messageBuf instanceof ArrayBuffer ? new Uint8Array(messageBuf) : messageBuf;\n\n//   const car = CarBufferReader.fromBytes(bytes);\n\n//   const recordsByCID = new Map();\n//   const keyByCID = new Map();\n//   const errors = [];\n//   const blocks = typeof car._blocks === 'object' && car._blocks && Array.isArray(car._blocks) ? car._blocks : car.blocks();\n//   const decoder = new TextDecoder();\n\n//   let iteration = 0;\n//   for (const block of blocks) {\n//     iteration++;\n//     if (iteration % YIELD_AFTER_ITERATION === YIELD_AFTER_ITERATION - 1) {\n//       const pauseStart = Date.now();\n//       yield;\n//       pauseTime += Date.now() - pauseStart;\n//     }\n\n//     const record = decodeCBOR(block.bytes);\n//     if (record.$type) recordsByCID.set(block.cid, record);\n//     else if (Array.isArray(record.e)) {\n//       let key = '';\n//       for (const sub of record.e) {\n//         iteration++;\n//         if (iteration % YIELD_AFTER_ITERATION === YIELD_AFTER_ITERATION - 1) {\n//           const pauseStart = Date.now();\n//           yield;\n//           pauseTime += Date.now() - pauseStart;\n//         }\n\n//         if (!sub.k || !sub.v) continue;\n//         try {\n//           const keySuffix = decoder.decode(sub.k);\n//           key = key.slice(0, sub.p || 0) + keySuffix;\n\n//           let cid;\n//           if (typeof sub.v === 'string') {\n//             cid = sub.v;\n//           } else if (sub.v.value) {\n//             const expandWithoutZero =\n//               sub.v.value[0] ? sub.v.value :\n//             /** @type {Uint8Array} */(sub.v.value).subarray(1);\n//             cid = decodeCID(expandWithoutZero);\n//           }\n\n//           if (!cid) continue;\n\n//           keyByCID.set(cid, key);\n//         } catch (error) {\n//           if (!errors.length) console.error(error);\n//           errors.push(error);\n//         }\n//       }\n//     }\n//   }\n\n//   /** @type {import('./firehose').FirehoseRecord[] & { parseTime: number }} */\n//   const records = /** @type {*} */([]);\n//   for (const entry of recordsByCID) {\n//     iteration++;\n//     if (iteration % YIELD_AFTER_ITERATION === YIELD_AFTER_ITERATION - 1) {\n//       const pauseStart = Date.now();\n//       records.parseTime = pauseStart - parseStart - pauseTime;\n//       yield;\n//       pauseTime += Date.now() - pauseStart;\n//     }\n\n//     const cid = entry[0];\n//     /** @type {import('./firehose').FirehoseRecord} */\n//     const record = entry[1];\n//     record.repo = did;\n//     const key = keyByCID.get(cid);\n//     if (key) {\n//       record.path = key;\n//       record.uri = 'at://' + did + '/' + key;\n//     }\n\n//     // let's recreate the record, to pack the GC and avoid deoptimized objects\n//     records.push(record);\n//   }\n\n//   // record.seq = commit.seq; 471603945\n//   // record.since = /** @type {string} */(commit.since); 3ksfhcmgghv2g\n//   // record.action = op.action;\n//   // record.cid = cid;\n//   // record.path = op.path;\n//   // record.timestamp = commit.time ? Date.parse(commit.time) : Date.now(); 2024-05-13T19:59:10.457Z\n\n//   // record.repo = fullDID;\n//   // record.uri = fullDID + '/' + 'op.path';\n//   // record.action = 'create';\n\n//   records.parseTime = Date.now() - parseStart - pauseTime;\n//   yield records;\n\n//   return records;\n// }\n\n/**\n * @param {ArrayBuffer | Uint8Array} messageBuf\n * @param {string} did\n * @returns {Generator<import('./firehose').FirehoseRecord[] & { parseTime: number } | undefined>}\n */\nexport function* sequenceReadCAR(messageBuf, did) {\n  if (typeof messageBuf === 'string')\n    [messageBuf, did] = /** @type {[any, any]} */([did, messageBuf]);\n\n  const parseStart = Date.now();\n  let pauseTime = 0;\n\n  const bytes = messageBuf instanceof ArrayBuffer ? new Uint8Array(messageBuf) : messageBuf;\n\n  const car = readCar(bytes);\n\n  const recordsByCID = new Map();\n  const keyByCID = new Map();\n  const errors = [];\n  const decoder = new TextDecoder();\n\n  let iteration = 0;\n  for (const block of car.iterate()) {\n    iteration++;\n    if (iteration % YIELD_AFTER_ITERATION === YIELD_AFTER_ITERATION - 1) {\n      const pauseStart = Date.now();\n      yield;\n      pauseTime += Date.now() - pauseStart;\n    }\n\n    const record = decodeCBOR2(block.bytes);\n    if (record.$type) {\n      const blockCID = 'b' + toBase32(block.cid.bytes);\n      recordsByCID.set(blockCID, record);\n    } else if (Array.isArray(record.e)) {\n      let key = '';\n      for (const sub of record.e) {\n        iteration++;\n        if (iteration % YIELD_AFTER_ITERATION === YIELD_AFTER_ITERATION - 1) {\n          const pauseStart = Date.now();\n          yield;\n          pauseTime += Date.now() - pauseStart;\n        }\n\n        if (!sub.k || !sub.v) continue;\n        try {\n          const keySuffix = decoder.decode(sub.k.buf);\n          key = key.slice(0, sub.p || 0) + keySuffix;\n\n          let cid;\n          if (typeof sub.v === 'string') {\n            cid = sub.v;\n          } else if (sub.v.value) {\n            const expandWithoutZero =\n              sub.v.value[0] ? sub.v.value :\n            /** @type {Uint8Array} */(sub.v.value).subarray(1);\n            cid = decodeCID2(expandWithoutZero);\n          } else if (sub.v.$bytes) {\n            cid = sub.v.$link;\n          }\n\n          if (!cid) continue;\n\n          keyByCID.set(cid, key);\n        } catch (error) {\n          if (!errors.length) console.error(error);\n          errors.push(error);\n        }\n      }\n    }\n  }\n\n  /** @type {import('./firehose').FirehoseRecord[] & { parseTime: number }} */\n  const records = /** @type {*} */([]);\n  for (const entry of recordsByCID) {\n    iteration++;\n    if (iteration % YIELD_AFTER_ITERATION === YIELD_AFTER_ITERATION - 1) {\n      const pauseStart = Date.now();\n      records.parseTime = pauseStart - parseStart - pauseTime;\n      yield;\n      pauseTime += Date.now() - pauseStart;\n    }\n\n    const cid = entry[0];\n    /** @type {import('./firehose').FirehoseRecord} */\n    const record = entry[1];\n    record.repo = did;\n    record.cid = cid;\n    const key = keyByCID.get(cid);\n    if (key) {\n      record.path = key;\n      record.uri = 'at://' + did + '/' + key;\n    }\n\n    // let's recreate the record, to pack the GC and avoid deoptimized objects\n    records.push(record);\n  }\n\n  // record.seq = commit.seq; 471603945\n  // record.since = /** @type {string} */(commit.since); 3ksfhcmgghv2g\n  // record.action = op.action;\n  // record.cid = cid;\n  // record.path = op.path;\n  // record.timestamp = commit.time ? Date.parse(commit.time) : Date.now(); 2024-05-13T19:59:10.457Z\n\n  // record.repo = fullDID;\n  // record.uri = fullDID + '/' + 'op.path';\n  // record.action = 'create';\n\n  records.parseTime = Date.now() - parseStart - pauseTime;\n  yield records;\n\n  return records;\n}\n", "{\n  \"name\": \"bski\",\n  \"version\": \"0.9.5\",\n  \"author\": \"Oleg Mihailik\",\n  \"license\": \"MIT\",\n  \"description\": \"BlueSky firehose/WebSocket and CAR in plain JavaScript\",\n  \"repository\": \"https://github.com/colds-ky/bski\",\n  \"main\": \"src/index.js\",\n  \"exports\": {\n    \"import\": \"./src/index.js\",\n    \"require\": \"./index.js\"\n  },\n  \"type\": \"module\",\n  \"scripts\": {\n    \"build\": \"esbuild src/index.js --bundle --sourcemap --global-name=bski --outfile=index.js\",\n    \"build-rollup\": \"npx rollup src/index.js --format=iife --sourcemap --name=bski --file=index.js\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [\n    \"bluesky\",\n    \"bsky\",\n    \"bski\",\n    \"atproto\",\n    \"firehose\",\n    \"car\",\n    \"dag/cbor\",\n    \"dag\",\n    \"cbor\"\n  ],\n  \"devDependencies\": {\n    \"esbuild\": \"^0.24.2\",\n    \"rollup\": \"^4.32.1\"\n  }\n}", "// @ts-check\n/// <reference types='@atproto/api' />\n\nimport { readCar } from './decode/car/reader';\nimport { fromBytes } from './decode/cbor/bytes';\nimport { toCIDLink } from './decode/cbor/cid-link';\nimport { decode, decodeFirst } from './decode/cbor/decode';\n\nimport { version } from '../package.json';\nexport { version };\n\nconst emptyUint8Array = new Uint8Array();\n\n/**\n * @typedef {{\n *  'app.bsky.feed.like': import('@atproto/api').AppBskyFeedLike.Record,\n *  'app.bsky.feed.post': import('@atproto/api').AppBskyFeedPost.Record,\n *  'app.bsky.feed.repost': import('@atproto/api').AppBskyFeedRepost.Record,\n *  'app.bsky.feed.threadgate': import('@atproto/api').AppBskyFeedThreadgate.Record,\n *  'app.bsky.graph.follow': import('@atproto/api').AppBskyGraphFollow.Record,\n *  'app.bsky.graph.block': import('@atproto/api').AppBskyGraphBlock.Record,\n *  'app.bsky.graph.list': import('@atproto/api').AppBskyGraphList.Record,\n *  'app.bsky.graph.listitem': import('@atproto/api').AppBskyGraphListitem.Record,\n *  'app.bsky.graph.listblock': import('@atproto/api').AppBskyGraphListblock.Record,\n *  'app.bsky.actor.profile': import('@atproto/api').AppBskyActorProfile.Record\n *  'app.bsky.feed.generator': import('@atproto/api').AppBskyFeedGenerator.Record\n *  'app.bsky.feed.postgate': import('@atproto/api').AppBskyFeedPostgate.Record\n *  'chat.bsky.actor.declaration': import('@atproto/api').ChatBskyActorDeclaration.Record,\n *  'app.bsky.graph.starterpack': import('@atproto/api').AppBskyGraphStarterpack.Record\n * }} RepositoryRecordTypes$\n */\n\n/**\n * @template {keyof RepositoryRecordTypes$} $Type\n * @typedef {RepositoryRecordTypes$[$Type] & {\n *  repo: string,\n *  uri: string,\n *  cid: string,\n *  action: 'create' | 'update',\n *  path: string,\n *  $type: $Type,\n *  since: string,\n *  time: string,\n *  receiveTimestamp: number,\n *  parseTime: number\n * }} FirehoseRepositoryRecord\n */\n\n/**\n * @typedef {{\n *  repo: string,\n *  uri: string,\n *  action: 'delete',\n *  path: string,\n *  $type: keyof RepositoryRecordTypes$,\n *  since: string,\n *  time: string,\n *  receiveTimestamp: number,\n *  parseTime: number\n * }} FirehoseDeleteRecord\n */\n\n\n/**\n * @typedef {{\n *  $type: '#identity',\n *  repo: string,\n *  action?: never,\n *  handle: string,\n *  time: string,\n *  receiveTimestamp: number,\n *  parseTime: number\n * }} FirehoseIdentityRecord\n */\n\n/**\n * @typedef {{\n *  $type: '#identity',\n *  repo: string,\n *  action?: never,\n *  active: boolean,\n *  time: string,\n *  receiveTimestamp: number,\n *  parseTime: number\n * }} FirehoseAccountRecord\n */\n\n/**\n * @typedef {{\n *  $type: 'error',\n *  action?: never,\n *  message: string,\n *  receiveTimestamp: number,\n *  parseTime: number\n * } & Record<string, unknown>} FirehoseErrorRecord\n */\n\n/**\n * @typedef {FirehoseRepositoryRecord<'app.bsky.feed.like'> |\n * FirehoseRepositoryRecord<'app.bsky.feed.post'> |\n * FirehoseRepositoryRecord<'app.bsky.feed.repost'> |\n * FirehoseRepositoryRecord<'app.bsky.feed.threadgate'> |\n * FirehoseRepositoryRecord<'app.bsky.graph.follow'> |\n * FirehoseRepositoryRecord<'app.bsky.graph.block'> |\n * FirehoseRepositoryRecord<'app.bsky.graph.list'> |\n * FirehoseRepositoryRecord<'app.bsky.graph.listitem'> |\n * FirehoseRepositoryRecord<'app.bsky.graph.listblock'> |\n * FirehoseRepositoryRecord<'app.bsky.actor.profile'> |\n * FirehoseRepositoryRecord<'app.bsky.feed.generator'> |\n * FirehoseRepositoryRecord<'app.bsky.feed.postgate'> |\n * FirehoseRepositoryRecord<'chat.bsky.actor.declaration'> |\n * FirehoseRepositoryRecord<'app.bsky.graph.starterpack'> |\n * FirehoseDeleteRecord |\n * FirehoseIdentityRecord |\n * FirehoseAccountRecord |\n * FirehoseErrorRecord\n * } FirehoseRecord\n */\n\nexport const known$Types = /** @type {const} */([\n  'app.bsky.feed.like', 'app.bsky.feed.post', 'app.bsky.feed.repost', 'app.bsky.feed.threadgate',\n  'app.bsky.graph.follow', 'app.bsky.graph.block', 'app.bsky.graph.list', 'app.bsky.graph.listitem', 'app.bsky.graph.listblock',\n  'app.bsky.actor.profile',\n  'app.bsky.feed.generator',\n  'app.bsky.feed.postgate',\n  'chat.bsky.actor.declaration',\n  'app.bsky.graph.starterpack'\n]);\n\nfirehose.knownTypes = known$Types;\n\nfunction requireWebsocket() {\n  const globalObj = typeof global !== 'undefined' && global || typeof globalThis !== 'undefined' && globalThis;\n  const requireFn = globalObj?.['require'];\n  if (typeof requireFn === 'function') return /** @type {typeof WebSocket} */(requireFn('ws'));\n  throw new Error('WebSocket not available');\n}\n\nfirehose.each = each;\nfirehose.version = version;\n\n/**\n * @param {string} [address]\n * @returns {AsyncGenerator<FirehoseRecord[], void, void>}\n */\nexport async function* firehose(address) {\n  const WebSocketImpl = typeof WebSocket === 'function' ? WebSocket :\n    requireWebsocket();\n\n  const wsAddress = address || 'wss://bsky.network/xrpc/com.atproto.sync.subscribeRepos';\n\n  const ws = new WebSocketImpl(wsAddress);\n  ws.binaryType = 'arraybuffer';\n  ws.addEventListener('message', handleMessage);\n  ws.addEventListener('error', handleError);\n  ws.addEventListener('close', handleClose)\n\n  let buf = createAwaitPromise();\n  let closed = false;\n\n  try {\n\n    while (true) {\n      await buf.promise;\n      if (buf.block?.length) {\n        const block = buf.block;\n        buf = createAwaitPromise();\n        if (closed) {\n          block['messages'] = block; // backwards compatibility trick\n          if (block.length) yield block;\n          break;\n        }\n        yield block;\n      } else {\n        buf = createAwaitPromise();\n      }\n    }\n  } finally {\n    if (!closed) {\n      try { ws.close(); }\n      catch (error) { }\n    }\n  }\n\n  function handleClose() {\n    closed = true;\n    buf.resolve();\n  }\n\n  function handleMessage(event) {\n    const receiveTimestamp = Date.now();\n\n    if (typeof event.data?.byteLength === 'number') {\n      parseMessageBufAndResolve(receiveTimestamp, event.data);\n    } else if (typeof event.data?.arrayBuffer === 'function') {\n      event.data.arrayBuffer().then(arrayBuffer => parseMessageBufAndResolve(receiveTimestamp, arrayBuffer))\n    } else {\n      buf.block.push({\n        $type: 'error',\n        message: 'WebSocket message type not supported.',\n        data: event.data,\n        receiveTimestamp,\n        parseTime: 0\n      });\n      buf.resolve();\n    }\n  }\n\n  /**\n   * @param {number} receiveTimestamp\n   * @param {ArrayBuffer} arrayBuf\n   */\n  function parseMessageBufAndResolve(receiveTimestamp, arrayBuf) {\n    parseMessageBuf(receiveTimestamp, new Uint8Array(arrayBuf));\n    buf.resolve();\n  }\n\n  /**\n   * @param {number} receiveTimestamp\n   * @param {Uint8Array} messageBuf\n   */\n  function parseMessageBuf(receiveTimestamp, messageBuf) {\n    const parseStart = performance.now();\n    try {\n      parseMessageBufWorker(receiveTimestamp, parseStart, messageBuf);\n      buf.resolve();\n    } catch (parseError) {\n      buf.block.push({\n        $type: 'error',\n        message: parseError.message,\n        receiveTimestamp,\n        parseTime: performance.now() - parseStart\n      });\n    }\n\n    buf.resolve();\n  }\n\n  /**\n * @param {number} receiveTimestamp\n * @param {number} parseStart\n * @param {Uint8Array} messageBuf\n */\n  function parseMessageBufWorker(receiveTimestamp, parseStart, messageBuf) {\n    const [header, remainder] = decodeFirst(messageBuf);\n    const [body, remainder2] = decodeFirst(remainder);\n    if (remainder2.length > 0) {\n      return buf.block.push({\n        $type: 'error',\n        message: 'Excess bytes in message.',\n        receiveTimestamp,\n        parseTime: performance.now() - parseStart\n      });\n    }\n\n    const { t, op } = header;\n\n    if (op === -1) {\n      return buf.block.push({\n        $type: 'error',\n        message: 'Error header#' + body.error + ': ' + body.message,\n        receiveTimestamp,\n        parseTime: performance.now() - parseStart\n      });\n    }\n\n    if (t === '#commit') {\n      const commit = body;\n\n      // A commit can contain no changes\n      if (!('blocks' in commit) || !(commit.blocks.$bytes.length)) {\n        return buf.block.push({\n          $type: 'com.atproto.sync.subscribeRepos#commit',\n          ...commit,\n          blocks: emptyUint8Array,\n          ops: [],\n          receiveTimestamp,\n          parseTime: performance.now() - parseStart\n        });\n      }\n\n      const blocks = fromBytes(commit.blocks);\n      const car = readCarToMap(blocks);\n      for (let opIndex = 0; opIndex < commit.ops.length; opIndex++) {\n        const op = commit.ops[opIndex];\n        const action = op.action;\n\n        const now = performance.now();\n        const record = op.cid ? car.get(op.cid) : undefined;\n\n        if (action === 'create' || action === 'update') {\n          if (!op.cid) {\n            buf.block.push({\n              $type: 'error',\n              message: 'Missing commit.ops[' + (opIndex - 1) + '].cid.',\n              receiveTimestamp,\n              parseTime: now - parseStart,\n              commit\n            });\n            parseStart = now;\n            continue;\n          }\n\n          if (!record) {\n            buf.block.push({\n              $type: 'error',\n              message: 'Unresolved commit.ops[' + (opIndex - 1) + '].cid ' + op.cid,\n              receiveTimestamp,\n              parseTime: now - parseStart,\n              commit\n            });\n            parseStart = now;\n            continue;\n          }\n\n          record.action = action;\n          record.uri = 'at://' + commit.repo + '/' + op.path;\n          record.path = op.path;\n          record.cid = op.cid;\n          record.receiveTimestamp = receiveTimestamp;\n          record.parseTime = now - parseStart;\n\n          buf.block.push(record);\n          continue;\n        } else if (action === 'delete') {\n          buf.block.push({\n            action,\n            path: op.path,\n            receiveTimestamp,\n            parseTime: now - parseStart\n          });\n          parseStart = now;\n        } else {\n          buf.block.push({\n            $type: 'error',\n            message: 'Unknown action ' + op.action,\n            ...record,\n            receiveTimestamp,\n            parseTime: now - parseStart\n          });\n          parseStart = now;\n          continue;\n        }\n      }\n      return;\n    }\n\n    return buf.block.push({\n      $type: t,\n      ...body,\n      receiveTimestamp,\n      parseTime: performance.now() - parseStart\n    });\n  }\n\n  function handleError(error) {\n    console.error(error);\n    const errorText =\n      error.message || 'WebSocket error ' + error;\n    buf.reject(new Error(errorText));\n  }\n\n}\n\nasync function* each() {\n  for await (const block of firehose()) {\n    yield* block;\n  }\n}\n\n/**\n * @returns {{\n *  block: FirehoseRecord[],\n *  resolve: () => void,\n *  reject: (reason?: any) => void,\n *  promise: Promise<void>\n * }} */\nfunction createAwaitPromise() {\n  const result = {\n    /** @type {FirehoseRecord[]} */\n    block: []\n  };\n  result.promise = new Promise((resolve, reject) => {\n    result.resolve = resolve;\n    result.reject = reject;\n  });\n  return /** @type {*} */(result);\n}\n\n/** @param {Uint8Array} buffer */\nfunction readCarToMap(buffer) {\n  const records = new Map();\n  for (const { cid, bytes } of readCar(buffer).iterate()) {\n    records.set(toCIDLink(cid), decode(bytes));\n  }\n  return records;\n}\n"],
  "mappings": "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",
  "names": ["version", "decode", "encode", "version", "decode", "prelude", "type", "info", "decodeFirst", "decode", "version", "decode", "readCid", "encode", "decode", "decodeFirst", "op", "decode"]
}
